# Coding Standards & Best Practices

This file details the mandatory coding standards for all code generated by AI agents. Strict adherence is required for code quality, maintainability, and consistency.

1. Language & Typing
TypeScript Everywhere:
Directive: All code (React, Next.js, React Native, Convex backend functions) must be written in TypeScript.
Strict Typing: Enable strict type checking in tsconfig.json.
Explicitness: Provide explicit types for all function arguments, return values, component props, state variables, and API responses. Avoid any type usage unless absolutely unavoidable (and justify its use with a comment).
Interfaces/Types: Define clear interfaces or types for all data structures (e.g., Convex records, API payloads).

2. Code Quality & Readability
Clean Code Principles:
Directive: Write concise, readable, and self-documenting code.
Simplicity: Prefer simple solutions over complex ones. Avoid unnecessary abstractions or "clever" code that hinders understanding.
DRY (Don't Repeat Yourself): Refactor duplicated logic into reusable functions or components.
Comments:
Directive: Provide clear, concise, and comprehensive comments for:
Complex logic or algorithms.
Non-obvious implementations or design choices.
Function headers (purpose, arguments, return values).
Component purpose and expected props.
Rationale: Essential for human review and future maintenance of AI-generated code.
Naming Conventions:
Directive:
Variables/Functions: camelCase (e.g., userName, getWhispers).
Constants: UPPER_SNAKE_CASE (e.g., MAX_WHISPER_LENGTH).
Components: PascalCase (e.g., WhisperCard, AuthScreen).
Files: kebab-case for component/feature directories (e.g., my-component/index.tsx), camelCase for utility files (e.g., dateFormatter.ts), kebab-case for Next.js/Expo Router files (e.g., sign-in.tsx).
Code Formatting:
Directive: Adhere to standard ESLint and Prettier configurations. Automatically format code.
Consistency: Maintain consistent indentation (2 spaces), brace style, and line endings.

3. Error Handling & Validation
Robust Error Handling:
Directive: Implement comprehensive try-catch blocks for all asynchronous operations (e.g., API calls to Clerk/Convex) and other potentially error-prone code.
Feedback: Provide clear, user-friendly error messages (via custom toast/modal, not alert() or confirm()).
Logging: Log errors to the console (for development) and consider future integration with a dedicated error logging service.
Input Validation:
Directive: Implement both client-side (for immediate user feedback) and server-side (Convex functions) input validation.
Client-Side: Use form validation libraries (e.g., React Hook Form with Zod for Web) or manual checks.
Server-Side: Mandatory to use Convex's validation utilities (v.string().min(1).max(280), v.id(), v.object()) in all mutations and queries that accept user input.

4. Performance Optimizations
UI Responsiveness (60 FPS):
Directive: Minimize expensive operations in render/build methods.
Techniques (React/React Native): Utilize React.memo, useCallback, useMemo hooks. Optimize list rendering with FlatList (RN) or virtualized lists (Web).
Application Load Time (Max 3s Cold Start):
Directive: Optimize initial bundle size and startup sequence.
Techniques (Web): Leverage Next.js Image/Font optimization, lazy loading.
Techniques (React Native): Use Expo's build optimizations, preloading assets.
Network Latency (Max 200ms for core interactions):
Directive: Optimize data fetching and real-time updates.
Techniques: Efficiently use Convex's live queries, implement optimistic UI updates, minimize redundant requests.

5. Forbidden Practices
alert() and confirm(): Absolutely forbidden in all generated code for all platforms. Use custom toast notifications or modal components instead.
Hardcoding Sensitive Data: Never hardcode API keys, secrets, or other sensitive credentials directly in the codebase. Use environment variables.
Direct DOM Manipulation (React): Avoid direct DOM manipulation; always work through React's declarative API.
