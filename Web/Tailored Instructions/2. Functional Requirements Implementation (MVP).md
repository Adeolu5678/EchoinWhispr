# Functional Requirements Implementation (MVP)

AI Agent, implement the core MVP features as defined in SSD Section 3.1 User Authentication and SSD Section 3.2 Core Messaging: Whispers.

2.1. User Authentication (FR-AUTH-001, FR-AUTH-002, FR-AUTH-003)
UI Components: Use Clerk's pre-built UI components for sign-up and sign-in.
For sign-up, use <SignUp path="/sign-up" routing="path" signInUrl="/sign-in" />.
For sign-in, use <SignIn path="/sign-in" routing="path" signUpUrl="/sign-up" />.
Place these components in app/(auth)/sign-up/page.tsx and app/(auth)/sign-in/page.tsx respectively.
Authentication Flow:
FR-AUTH-001 User Registration: When a user registers via Clerk's UI, ensure the clerkUserId, email, username (derived from email, e.g., "user123"), and displayName (initially same as username) are automatically synced to the users table in Convex via a Convex mutation trigger or webhook setup.
FR-AUTH-002 User Login: After successful login via Clerk, redirect the user to the main application home page (/).
FR-AUTH-003 Session Management: Rely entirely on Clerk's SDK for secure session management.
Protected Routes: Implement middleware or component-level checks to protect routes that require authentication. Unauthenticated users attempting to access protected routes should be redirected to /sign-in.

2.2. Core Messaging: Whispers
2.2.1. Sending a Whisper (FR-WHISP-001)
UI:
Create a "Compose Whisper" component (features/whispers/components/ComposeWhisper.tsx).
This component will contain a Shadcn Textarea for whisper content (max 280 characters with character counter).
Include a Shadcn Input for the recipient's username or email.
Provide a Shadcn Button labeled "Send Whisper".
Logic:
Implement client-side validation for textContent (non-empty, max 280 chars) and recipientIdentifier (non-empty).
Upon valid input and button click, call a Convex mutation (api.whispers.sendWhisper) with textContent and recipientIdentifier.
Handle success with a toast notification (e.g., using a Shadcn Toast component) and clear the input fields.
Handle errors by displaying clear messages using the Toast component.
Convex Mutation (api.whispers.sendWhisper):
This mutation will:
Accept textContent (string) and recipientIdentifier (string).
Verify ctx.auth.userId exists.
Look up receiverId from the users table based on recipientIdentifier.
Insert a new record into the whispers table with textContent, senderId (from ctx.auth.userId), receiverId, and initial status: 'sent'.
2.2.2. Receiving & Displaying Whispers (FR-WHISP-002, FR-WHISP-003)
UI:
Create a main "Whisper Inbox" screen (features/whispers/components/WhisperInbox.tsx or main app/page.tsx).
Display whispers in a list format, using a Shadcn Card or similar component for each whisper (features/whispers/components/WhisperCard.tsx).
Logic:
Use a Convex live query (api.whispers.getIncomingWhispers) to fetch whispers where receiverId matches ctx.auth.userId and status is not read. Order by createdAt descending.
Implement real-time updates: as new whispers arrive, they should appear dynamically at the top of the list without page refresh.
Upon displaying a whisper to the user (e.g., after it enters the viewport), call a Convex mutation (api.whispers.markWhisperAsRead) to update its status to read and set readAt.
WhisperCard UI:
Show textContent prominently.
Display createdAt timestamp (formatted for readability, e.g., "5m ago", "Yesterday").
Sender identity must be displayed as "Anonymous".
Include a subtle visual indicator for unread whispers (e.g., a distinct background color for unread cards).
Convex Query (api.whispers.getIncomingWhispers):
This query will:
Verify ctx.auth.userId exists.
Fetch whispers where receiverId matches ctx.auth.userId.
Ensure senderId is never directly returned to the client for recipient.
Return textContent, createdAt, status, and _id.
Convex Mutation (api.whispers.markWhisperAsRead):
This mutation will:
Accept whisperId (Convex ID).
Verify ctx.auth.userId is the receiverId of the whisper.
Update the whisper's status to read and set readAt to current timestamp.
