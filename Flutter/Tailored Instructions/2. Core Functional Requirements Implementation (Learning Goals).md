# Core Functional Requirements Implementation (Learning Goals)

AI Agent, your goal is to guide the human developer in implementing the core MVP features, mirroring those defined in SSD Section 3.1 User Authentication and SSD Section 3.2 Core Messaging: Whispers, but tailored for Flutter development.

2.1. User Authentication (FR-AUTH-001, FR-AUTH-002, FR-AUTH-003)
UI Components: Guide the developer to build Flutter widgets for sign-up and sign-in.
Use TextFormField for input fields.
Use ElevatedButton for actions.
Focus on creating a clean UI with Container, Column, Row widgets.
Authentication Flow:
FR-AUTH-001 User Registration:
Instruct on calling the ClerkAuthService for registration.
Explain how to securely store the session token using flutter_secure_storage.
Detail the process of creating a corresponding user in Convex via the ConvexClient (e.g., after successful Clerk registration, trigger a Convex mutation to create a user record with clerkUserId, email, username, displayName).
FR-AUTH-002 User Login:
Instruct on calling the ClerkAuthService for login.
Explain session token handling.
Guide on navigating to the home screen using Flutter's Navigator.
FR-AUTH-003 Session Management:
Explain how to persist and retrieve authentication state (e.g., using flutter_secure_storage and an AuthStateProvider with StreamBuilder).
Demonstrate redirect logic based on authentication status.
Example: ClerkAuthService (Conceptual Dart)
// lib/services/clerk_auth_service.dart
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class ClerkAuthService {
  final String _clerkBaseUrl = 'https://api.clerk.dev/v1';
  final String _clerkPublishableKey = 'pk_YOUR_CLERK_PUBLISHABLE_KEY'; // Replace with actual key
  final _storage = const FlutterSecureStorage();

  Future<String?> signUp(String email, String password) async {
    // Implement HTTP POST to Clerk's sign-up endpoint
    // On success, store token and return it
    // On failure, throw an exception
    return null; // Placeholder
  }

  Future<String?> signIn(String email, String password) async {
    // Implement HTTP POST to Clerk's sign-in endpoint
    // On success, store token and return it
    // On failure, throw an exception
    return null; // Placeholder
  }

  Future<void> signOut() async {
    await _storage.delete(key: 'clerk_session_token');
    // Optionally revoke token with Clerk API
  }

  Future<String?> getToken() async {
    return await _storage.read(key: 'clerk_session_token');
  }
}

2.2. Core Messaging: Whispers
2.2.1. Sending a Whisper (FR-WHISP-001)
UI:
Guide to create a "Compose Whisper" StatefulWidget (e.g., features/whispers/presentation/widgets/ComposeWhisper.dart).
Use TextFormField with maxLines for whisper content, and a Text widget for character counter.
Use another TextFormField for recipient username/email.
Implement an ElevatedButton for "Send Whisper".
Logic:
Explain client-side validation using Form and TextFormField validators.
Instruct on calling a ConvexClient mutation for sendWhisper with textContent and recipientIdentifier.
Demonstrate displaying a SnackBar for success/error messages.
Convex Mutation (api.whispers.sendWhisper - Conceptual Dart interaction):
// In ConvexClient or WhisperRepository
Future<void> sendWhisper(String content, String recipientIdentifier) async {
  final token = await _clerkAuthService.getToken();
  if (token == null) throw Exception('Not authenticated');

  final response = await http.post(
    Uri.parse('$_convexBaseUrl/api/mutation'),
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $token',
    },
    body: jsonEncode({
      'function': 'whispers:sendWhisper', // This would be your Convex function name
      'args': {
        'textContent': content,
        'recipientIdentifier': recipientIdentifier,
      },
    }),
  );
  if (response.statusCode != 200) {
    throw Exception('Failed to send whisper: ${response.body}');
  }
}

Guidance: Emphasize that the Convex function (whispers:sendWhisper) on the backend must handle fetching the receiverId and inserting the whisper record as described in SSD Section 3.2.1.
2.2.2. Receiving & Displaying Whispers (FR-WHISP-002, FR-WHISP-003)
UI:
Guide to create a "Whisper Inbox" screen (features/whispers/presentation/pages/WhisperInboxPage.dart).
Use a ListView.builder to efficiently display a list of whispers.
Create a WhisperCard StatelessWidget (e.g., features/whispers/presentation/widgets/WhisperCard.dart) for each whisper.
Logic:
Real-time Simulation: Since direct Convex live queries might not have a native Flutter SDK, guide the developer to implement a polling mechanism (e.g., Timer.periodic) or conceptual WebSocket integration to simulate real-time updates.
Instruct on calling a ConvexClient query (e.g., getIncomingWhispers).
Explain state management (e.g., ChangeNotifierProvider with Consumer or Riverpod for reactive UI updates).
Guide on updating whisper status to read upon display, calling a Convex mutation (markWhisperAsRead).
WhisperCard UI:
Show textContent prominently using Text.
Display formatted createdAt timestamp.
Sender identity must be displayed as "Anonymous" (Flutter Text widget).
Include a subtle visual indicator for unread whispers (e.g., distinct Card background color or an Icon).
Convex Query (api.whispers.getIncomingWhispers - Conceptual Dart interaction):
// In ConvexClient or WhisperRepository
Future<List<Map<String, dynamic>>> getIncomingWhispers() async {
  final token = await _clerkAuthService.getToken();
  if (token == null) throw Exception('Not authenticated');

  final response = await http.post(
    Uri.parse('$_convexBaseUrl/api/query'),
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer $token',
    },
    body: jsonEncode({
      'function': 'whispers:getIncomingWhispers', // Your Convex function name
      'args': {},
    }),
  );
  if (response.statusCode == 200) {
    return List<Map<String, dynamic>>.from(jsonDecode(response.body));
  } else {
    throw Exception('Failed to fetch whispers: ${response.body}');
  }
}

Guidance: Remind that the Convex function (whispers:getIncomingWhispers) on the backend must ensure senderId is never directly returned to the client for the recipient, as per SSD Section 3.2.3.
