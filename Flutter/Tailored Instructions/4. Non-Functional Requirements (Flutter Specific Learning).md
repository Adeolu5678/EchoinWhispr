# Flutter Non-Functional Requirements Guidance

AI Agent, guide the developer to implement the Flutter application keeping in mind the following non-functional requirements from SSD Section 4, applying Flutter-specific best practices.

4.1. Performance
UI Responsiveness (60 FPS):
Guidance: Emphasize minimizing expensive operations in build() methods. Use const constructors where possible to prevent unnecessary widget rebuilds.
Techniques: Advise on using ListView.builder for efficient list rendering. Explain widget lifecycle and setState judiciously.
Application Load Time (Max 3s Cold Start):
Guidance: Advise on optimizing asset loading and initial widget tree construction.
Techniques: Explain flutter build --split-debug-info for release builds.
Network Latency (Max 200ms):
Guidance: Explain efficient HTTP request patterns.
Techniques: Implement asynchronous operations with async/await correctly. Provide loading indicators during network requests (e.g., CircularProgressIndicator).

4.2. Security
Authentication & Authorization:
Guidance: Reiterate that Clerk handles the core security.
Techniques: Ensure secure storage of tokens using flutter_secure_storage. Always use https for API calls.
Input Validation:
Guidance: Implement client-side validation using TextFormField's validator property.
Techniques: Reinforce the necessity of server-side validation (handled by Convex).

4.3. Usability (1-minute first whisper)
Guidance: Focus on a clear, logical flow using Flutter's navigation.
Techniques: Provide immediate visual feedback with SnackBar or AlertDialog. Ensure large, easy-to-tap ElevatedButtons.

4.4. Maintainability
Guidance: Strongly advocate for Flutter best practices.
Techniques:
Clean Code: Write concise and readable Dart code.
Comments: Add high-quality comments to widgets, functions, and classes.
Modularity: Adhere strictly to the lib/features structure.
Type Safety: Leverage Dart's static typing and null safety.
State Management: Suggest a robust state management solution like Provider or Riverpod for complex states, and StatefulWidget for local widget state.
Consistent Styling: Utilize Flutter's theming capabilities (ThemeData).

4.5. Reliability
Guidance: Implement robust error handling.
Techniques: Use try-catch blocks for network requests and other potential failure points. Display user-friendly error messages.
